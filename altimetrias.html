<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>Altimetría desde GPX (tramos parciales incluidos)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      body {
        background: #222;
        color: #eee;
        font-family: sans-serif;
        padding: 12px;
      }
      input {
        margin-bottom: 8px;
      }
      .label {
        font-size: 12px;
        text-anchor: middle;
        fill: white;
        font-weight: bold;
      }
      svg {
        background: #1e1e1e;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <h3>Sube tu archivo GPX</h3>
    <input type="file" id="gpxInput" accept=".gpx" />
    <svg id="chart" width="900" height="300"></svg>

    <script>
      const svg = d3.select("#chart");

      const width = +svg.attr("width");
      const height = +svg.attr("height");
      const margin = { top: 20, right: 30, bottom: 36, left: 56 };
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

      function haversine(lat1, lon1, lat2, lon2) {
        const R = 6371; // km
        const toRad = Math.PI / 180;
        const dLat = (lat2 - lat1) * toRad;
        const dLon = (lon2 - lon1) * toRad;
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos(lat1 * toRad) *
            Math.cos(lat2 * toRad) *
            Math.sin(dLon / 2) ** 2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }

      function colorForGradient(g) {
        if (g >= 10) return "#e7004c";
        if (g >= 8) return "#f54a40";
        if (g >= 5) return "#fd7d38";
        if (g >= 3) return "#ffc100";
        return "#cbff3f";
      }

      // Interpolar altitud en un punto dado (km) usando puntos adyacentes
      function sampleAt(data, targetKm) {
        if (targetKm <= data[0].km) return { km: data[0].km, alt: data[0].alt };
        const n = data.length;
        if (targetKm >= data[n - 1].km)
          return { km: data[n - 1].km, alt: data[n - 1].alt };
        for (let i = 0; i < n - 1; i++) {
          const a = data[i],
            b = data[i + 1];
          if (a.km <= targetKm && targetKm <= b.km) {
            const span = b.km - a.km;
            if (span === 0) return { km: targetKm, alt: a.alt };
            const t = (targetKm - a.km) / span;
            return { km: targetKm, alt: a.alt + t * (b.alt - a.alt) };
          }
        }
        // fallback
        return { km: data[n - 1].km, alt: data[n - 1].alt };
      }

      document
        .getElementById("gpxInput")
        .addEventListener("change", async (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const text = await file.text();
          const parser = new DOMParser();
          const xml = parser.parseFromString(text, "application/xml");

          // limpiar SVG (para cargas múltiples)
          svg.selectAll("*").remove();

          // extraer trkpt
          const trkpts = [...xml.querySelectorAll("trkpt")]
            .map((pt) => {
              const eleNode = pt.querySelector("ele");
              const ele = eleNode ? parseFloat(eleNode.textContent) : NaN;
              return {
                lat: parseFloat(pt.getAttribute("lat")),
                lon: parseFloat(pt.getAttribute("lon")),
                ele: ele,
              };
            })
            .filter((p) => !isNaN(p.ele)); // descartamos puntos sin ele si existen

          if (trkpts.length < 2) {
            alert("GPX inválido o sin elevaciones.");
            return;
          }

          // calcular distancia acumulada (en km)
          let dist = 0;
          const data = trkpts.map((p, i) => {
            if (i > 0) {
              dist += haversine(
                trkpts[i - 1].lat,
                trkpts[i - 1].lon,
                p.lat,
                p.lon
              );
            }
            return { km: dist, alt: p.ele };
          });

          const totalKm = data[data.length - 1].km;
          const segCount = Math.max(1, Math.ceil(totalKm)); // incluye tramo parcial final

          // construir segmentos (incluye tramo parcial final)
          const segments = [];
          for (let i = 0; i < segCount; i++) {
            const segStart = i;
            const segEnd = Math.min(i + 1, totalKm);
            // puntos dentro del intervalo [segStart, segEnd]
            let kmPoints = data.filter(
              (d) => d.km >= segStart && d.km <= segEnd
            );

            // asegurar que hay puntos en los límites (interpolar si hace falta)
            if (kmPoints.length === 0) {
              // no hay puntos en el intervalo -> crear start/end interpolados
              const a = sampleAt(data, segStart);
              const b = sampleAt(data, segEnd);
              kmPoints = [a, b];
            } else {
              // si no hay punto justo en segStart, insertar
              if (Math.abs(kmPoints[0].km - segStart) > 1e-6) {
                kmPoints.unshift(sampleAt(data, segStart));
              }
              // si no hay punto justo en segEnd, añadir
              const last = kmPoints[kmPoints.length - 1];
              if (Math.abs(last.km - segEnd) > 1e-6) {
                kmPoints.push(sampleAt(data, segEnd));
              }
            }

            const gain = kmPoints[kmPoints.length - 1].alt - kmPoints[0].alt;
            const distance_m = (segEnd - segStart) * 1000;
            const gradient = distance_m > 0 ? (gain / distance_m) * 100 : 0;

            segments.push({
              x0: segStart,
              x1: segEnd,
              points: kmPoints,
              gradient,
              mid: (segStart + segEnd) / 2,
            });
          }

          // escalas
          const x = d3
            .scaleLinear()
            .domain([0, totalKm])
            .range([0, innerWidth]);

          const y = d3
            .scaleLinear()
            .domain([d3.min(data, (d) => d.alt), d3.max(data, (d) => d.alt)])
            .nice()
            .range([innerHeight, 0]);

          // grupo principal
          const g = svg
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

          // generador área (hasta la base)
          const area = d3
            .area()
            .x((d) => x(d.km))
            .y0(innerHeight)
            .y1((d) => y(d.alt))
            .curve(d3.curveBasis);

          // pintar cada tramo como área (incluye último parcial)
          segments.forEach((seg) => {
            g.append("path")
              .datum(seg.points)
              .attr("fill", colorForGradient(seg.gradient))
              .attr("opacity", 0.25)
              .attr("d", area);
          });

          // línea de perfil por encima
          const line = d3
            .line()
            .x((d) => x(d.km))
            .y((d) => y(d.alt))
            .curve(d3.curveBasis);

          // --- GRID DE FONDO ---
          g.append("g")
            .attr("class", "grid grid-x")
            .attr("transform", `translate(0,${innerHeight})`)
            .call(
              d3
                .axisBottom(x)
                .ticks(Math.ceil(totalKm))
                .tickSize(-innerHeight)
                .tickFormat("") // no mostrar texto en el grid
            )
            .selectAll("line")
            .attr("stroke", "#444")
            .attr("stroke-opacity", 0.4);

          g.append("g")
            .attr("class", "grid grid-y")
            .call(d3.axisLeft(y).ticks(5).tickSize(-innerWidth).tickFormat(""))
            .selectAll("line")
            .attr("stroke", "#444")
            .attr("stroke-opacity", 0.4);

          g.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "#ffffff")
            .attr("stroke-width", 1)
            .attr("d", line);

          const labelGroup = g.append("g").attr("class", "labels");

          segments.forEach((seg) => {
            const labelColor = colorForGradient(seg.gradient);

            // Texto con el % de pendiente
            labelGroup
              .append("text")
              .attr("x", x(seg.mid))
              .attr("y", innerHeight - 8)
              .attr("text-anchor", "middle")
              .attr("fill", labelColor)
              .attr("font-weight", "bold")
              .attr("font-size", "12px")
              .text(seg.gradient.toFixed(1));

            // Barra proporcional al tramo real
            const barWidth = innerWidth * (seg.x1 - seg.x0) / totalKm;

            labelGroup
              .append("line")
              .attr("x1", (x(seg.mid) - barWidth / 2) + 2)
              .attr("x2", (x(seg.mid) + barWidth / 2) - 2)
              .attr("y1", innerHeight - 2)
              .attr("y2", innerHeight - 2)
              .attr("stroke", labelColor)
              .attr("stroke-width", 2);
          });
          // ejes
          g.append("g")
            .attr("transform", `translate(0,${innerHeight})`)
            .call(
              d3
                .axisBottom(x)
                .ticks(Math.ceil(totalKm))
                .tickFormat((d) => d + " km")
            );

          g.append("g").call(d3.axisLeft(y));

          // (opcional) texto resumen
          svg
            .append("text")
            .attr("x", 12)
            .attr("y", 14)
            .attr("fill", "#ddd")
            .text(
              `Total: ${totalKm.toFixed(2)} km — Tramos: ${segments.length}`
            );
        });
    </script>
  </body>
</html>
